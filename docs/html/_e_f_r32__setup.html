<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>RAIL: EFR32 Setup</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RAIL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="http://www.silabs.com"><span>silabs.com</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_e_f_r32__setup.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">EFR32 Setup </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>While RAIL attempts to be chip agnostic there are certain hardware differences that can't be overlooked. Where possible, missing features will be simulated in software, but performance characteristics may vary. This section will cover what differs for the EFR32.</p>
<h2>Hardware Initialization</h2>
<p>The EFR32 comes with versions of EMLIB and EMDRV to create a basic HAL layer. A lot of this initialization code is completely up to you, but there are a couple of requirements when you're building a RAIL app. Specifically, the radio will only work if you are running off a high precision crystal oscillator. Since some APIs will assume this is running you should make sure to initialize and switch to the crystal before calling any radio APIs.</p>
<p>For the WSTK you can use the crystal configuration stored in the bspconfig.h header file for your specific kit. Example code for this is shown below. If you have a custom hardware layout you may want to create your own HFXOInit structure to account for things like your specific CTUNE value.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;bsp.h&quot;</span> <span class="comment">// Contains WSTK versions of the HFXO init structure</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> efrStartup(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  CMU_HFXOInit_TypeDef hfxoInit = CMU_HFXOINIT_WSTK_DEFAULT;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Initialize the HFXO using the settings from the WSTK bspconfig.h</span></div>
<div class="line">  <span class="comment">// Note: This configures things like the capacitive tuning CTUNE variable</span></div>
<div class="line">  <span class="comment">//   which can vary based on your hardware design.</span></div>
<div class="line">  CMU_HFXOInit(&amp;hfxoInit);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Switch HFCLK to HFXO and disable HFRCO</span></div>
<div class="line">  CMU_ClockSelectSet(cmuClock_HF, cmuSelect_HFXO);</div>
<div class="line">  CMU_OscillatorEnable(cmuOsc_HFRCO, <span class="keyword">false</span>, <span class="keyword">false</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Radio Specific Initialization</h2>
<p>Currently there are two initialization functions for the radio that depend on your board configuration and must be manually called at startup. You <b>MUST</b> initialize the power amplifier (PA) in order to transmit. You <b>MUST</b> also initialize the PA before intializing RAIL for the library to properly account for the PA settings during timing calculations. You may initialize the packet trace (PTI) interface if you want to use this for debugging.</p>
<h3>Power Amplifier (PA) Initialization</h3>
<p>There are several different PAs available for the EFR32 family of chips. The specific set of PAs you have available and the supported power levels are determined by what part number you're using. To fully understand your part and what options you have please consult the data sheet for your part.</p>
<p>Once you have chosen the PA configuration that you need it's important that you initialize the PA before doing any radio operations, but after the HFXO has been enabled and switched to. The structures and APIs for doing this can be found in the pa.h file. An example of initializing the high power 2.4GHz PA is shown below.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;pa.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> initPa(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  RADIO_PAInit_t paInit = {</div>
<div class="line">    PA_SEL_2P4_HP,    <span class="comment">// Mode: PA_SEL_SUBGIG, PA_SEL_2P4_LP, PA_SEL_2P4_HP</span></div>
<div class="line">    PA_VOLTMODE_DCDC, <span class="comment">// VPA mode: PA_VOLTMODE_VBAT, PA_VOLTMODE_DCDC</span></div>
<div class="line">    100,              <span class="comment">// Desired output power in dBm * 10</span></div>
<div class="line">    0,                <span class="comment">// Output power offset in dBm * 10</span></div>
<div class="line">    10,               <span class="comment">// Desired ramp time in us</span></div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Initialize the PA (must be done only after the HFXO is enabled)</span></div>
<div class="line">  RADIO_PA_Init(&amp;paInit);</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Packet Trace (PTI) Initialization</h3>
<p>Packet trace on the EFR32 provides a mechanism for viewing transmitted and received radio packets for network sniffing or debugging. It can also be captured by a WSTK and sent to Simplicity Studio for viewing the data in its Network Analyzer tool.</p>
<p>If you want to use this functionality, you must configure what pins you want to use for this output and, optionally how you want to format the data. Note that the WSTK requires the following output format: </p>
<pre class="fragment">Mode: 8 bit UART mode
Baudrate: 1.6Mbps
Framing Signal: Enabled
</pre><p>If you change anything here it is currently unsupported by the WSTK. In the future we may include support for alternate output modes.</p>
<p>To choose the pins you want you must look in the data sheet for your part and select a valid route location for the FRC_DOUT and FRC_DFRAME signals. These map to PTI.DATA and PTI.FRAME on the WSTK respectively. Once you've found pins that work for your hardware you need to configure the RouteLocation, port, and pin fields in the PTI initialization structure. When using the WSTK for example, you should initialize things as follows.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;pti.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> initPti(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  RADIO_PTIInit_t ptiInit =   {</div>
<div class="line">    RADIO_PTI_MODE_UART,    <span class="comment">// Only supported output mode for the WSTK</span></div>
<div class="line">    1600000,                <span class="comment">// Choose 1.6 Mbps for the WSTK</span></div>
<div class="line">    6,                      <span class="comment">// WSTK uses location 6 for DOUT</span></div>
<div class="line">    gpioPortB,              <span class="comment">// FRC_DOUT#6 is PB12</span></div>
<div class="line">    12,                     <span class="comment">// FRC_DOUT#6 is PB12</span></div>
<div class="line">    6,                      <span class="comment">// UNUSED IN UART MODE</span></div>
<div class="line">    gpioPortB,              <span class="comment">// UNUSED IN UART MODE</span></div>
<div class="line">    11,                     <span class="comment">// UNUSED IN UART MODE</span></div>
<div class="line">    6,                      <span class="comment">// WSTK uses location 6 for DFRAME</span></div>
<div class="line">    gpioPortB,              <span class="comment">// FRC_DOUT#6 is PB13</span></div>
<div class="line">    13,                     <span class="comment">// FRC_DOUT#6 is PB13</span></div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Initialize the Packet Trace Interface (PTI)</span></div>
<div class="line">  RADIO_PTI_Init(&amp;ptiInit);</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Other Radio GPIO Functions</h3>
<p>There are various useful signals related to the radio that can be output on a GPIO using the Peripheral Reflex System (PRS). The PRS is an advanced system where you can route signals to channels and then output those channels to a number of configurable locations. There's a lot more to it than that, so consult the reference manual chapter on the PRS if you want to understand it better.</p>
<p>A list of some of the most interesting PRS signals related to the radio is shown below along with how to enable them in the PRS.</p>
<table class="doxtable">
<tr>
<th align="left">Signal </th><th align="left">Summary </th><th align="left">PRS Source </th><th align="left">PRS Signal  </th></tr>
<tr>
<td align="left">RACACTIVE </td><td align="left">Radio enabled </td><td align="left">0x20 </td><td align="left">0x00 </td></tr>
<tr>
<td align="left">RACTX </td><td align="left">Transmit mode enabled </td><td align="left">0x20 </td><td align="left">0x01 </td></tr>
<tr>
<td align="left">RACRX </td><td align="left">Receive mode enabled </td><td align="left">0x20 </td><td align="left">0x02 </td></tr>
<tr>
<td align="left">RACLNAEN </td><td align="left">LNA enabled for Rx </td><td align="left">0x20 </td><td align="left">0x03 </td></tr>
<tr>
<td align="left">RACPAEN </td><td align="left">PA enabled for Tx </td><td align="left">0x20 </td><td align="left">0x04 </td></tr>
<tr>
<td align="left">MODEM_FRAMEDET </td><td align="left">Frame detected </td><td align="left">0x26 </td><td align="left">0x00 </td></tr>
<tr>
<td align="left">MODEM_PREDET </td><td align="left">Preamble detected </td><td align="left">0x26 </td><td align="left">0x01 </td></tr>
<tr>
<td align="left">MODEM_TIMDET </td><td align="left">Timing detected </td><td align="left">0x26 </td><td align="left">0x02 </td></tr>
<tr>
<td align="left">MODEM_FRAMESENT </td><td align="left">Frame sent </td><td align="left">0x26 </td><td align="left">0x03 </td></tr>
<tr>
<td align="left">MODEM_SYNCSENT </td><td align="left">Syncword sent </td><td align="left">0x26 </td><td align="left">0x04 </td></tr>
<tr>
<td align="left">MODEM_PRESENT </td><td align="left">Preamble sent </td><td align="left">0x26 </td><td align="left">0x05 </td></tr>
</table>
<p>The example below shows you how to configure a PRS channel to output RACRX on a GPIO. For this example we assume you're using the SLWSTK6001A_EFR32MG kit. The specified configuration will put RACRX on PRS Channel 0 and output PRS Channel 0 on the EFR32's PC10 which is wired to WSTK_P12 and EXP_HEADER15 on the WSTK.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;em_cmu.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;em_gpio.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;em_device.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> enableDebugGpios(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Turn on the PRS and GPIO clocks so we can access their registers</span></div>
<div class="line">  CMU_ClockEnable(cmuClock_PRS, <span class="keyword">true</span>);</div>
<div class="line">  CMU_ClockEnable(cmuClock_GPIO, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Configure PC10 as an output</span></div>
<div class="line">  GPIO_PinModeSet(gpioPortC, 10, gpioModePushPull, 0);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Configure PRS Channel 0 to output RACRX</span></div>
<div class="line">  PRS-&gt;CH[0].CTRL = (0x20 &lt;&lt; _PRS_CH_CTRL_SOURCESEL_SHIFT)</div>
<div class="line">                     | (0x02 &lt;&lt; _PRS_CH_CTRL_SIGSEL_SHIFT)</div>
<div class="line">                     | PRS_CH_CTRL_EDSEL_OFF;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Configure PRS Channel 0 to use output location 12 (PC10 - see datasheet)</span></div>
<div class="line">  PRS-&gt;ROUTELOC0 &amp;= ~_PRS_ROUTELOC0_CH0LOC_MASK;</div>
<div class="line">  PRS-&gt;ROUTELOC0 |= PRS_ROUTELOC0_CH0LOC_LOC12;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Enable PRS Channel 0</span></div>
<div class="line">  PRS-&gt;ROUTEPEN |= PRS_ROUTEPEN_CH0PEN;</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Required Dependencies</h2>
<p>Most of the RAIL library is self contained, however, there are some dependencies on external functions. Specifically, we rely on functions from the C standard library, EMLIB, and CMSIS. Below is a complete list of these dependencies. If you want to change the implementation of any of these functions while maintaining the functionality that's fine, just know that they could impact RAIL operation.</p>
<table class="doxtable">
<tr>
<th>Group </th><th>Functions  </th></tr>
<tr>
<td>CMSIS </td><td><code>SystemHFXOClockGet()</code><br/>
<code>SystemLFRCOClockGet()</code><br/>
<code>SystemLFXOClockGet()</code><br/>
<code>SystemULFRCOClockGet()</code> </td></tr>
<tr>
<td>EMLIB (em_int) </td><td><code>INT_Disable()</code><br/>
<code>INT_Enable()</code> </td></tr>
<tr>
<td>EMLIB (em_cmu) </td><td><code>CMU_ClockFreqGet()</code><br/>
<code>CMU_ClockEnable()</code><br/>
<code>CMU_ClockSelectSet()</code><br/>
<code>CMU_OscillatorEnable()</code> </td></tr>
<tr>
<td>EMLIB (em_gpio) </td><td><code>GPIO_PinModeSet()</code> </td></tr>
<tr>
<td>EMLIB (em_system) </td><td><code>SYSTEM_ChipRevisionGet()</code> </td></tr>
<tr>
<td>stdlib </td><td><code>memcpy()</code><br/>
<code>memset()</code> </td></tr>
</table>
<h2>Peripherals Consumed by RAIL</h2>
<p>For now, RAIL consumes only peripherals that are a part of the radio. In the future we will likely need to use a few of the customer facing peripherals for enhanced functionality. To prepare you for this we're listing peripherals likely to be shared with RAIL in the future.</p>
<ul>
<li>PRS Channels<ul>
<li>RAIL will likely need one or two PRS channels to perform various synchronization and signaling. We will leave the vast majority of these channels alone so that they can be used by customers.</li>
</ul>
</li>
<li>RTCC Timer<ul>
<li>While RAIL won't require the whole RTCC timer we will need to use one channel of it to synchronize our internal timebase across deep sleep.</li>
<li>This is required because the RTCC timer should be one of the only timers to run throughout deep sleep and we don't want the RAIL timebase to slip every time we go to sleep.</li>
</ul>
</li>
</ul>
<h2>Entropy Generation</h2>
<p>The EFR32 supports true entropy collection using the radio. It is able to collect 1 bit per radio clock cycle while in receive mode. This means that we must enable the receiver when collecting entropy and if you attempt to transmit or otherwise delay entry into receive it will take us a longer time to collect the data. You can still receive packets while collecting entropy and this does mean that requesting random numbers longer than the length of your preamble and sync word may trigger a packet reception. This may be fixed in a future revision but for now this is done to ensure proper packet reception during random data collection.</p>
<p>Due to the nature of random data collection we will always wait for the full amount requested so we should return either the number of bytes requested or zero. Zero is returned if the radio is uninitialized and cannot be enabled for collection.</p>
<h2>Radio Calibration</h2>
<p>The EFR32 supports two radio calibration options: image rejection (IR) calibration and VCO temperature calibration. You may choose to enable one or both of these based upon your specific situation. We always recommend using both, but here is more information.</p>
<ul>
<li>Image Rejection Calibration (IRCAL)<ul>
<li>This calibration should be run once every time your PHY config changes. It is based on the modulation scheme, frequency band, and other radio settings. RAIL will request this via the <a class="el" href="group___calibration.html#ga0bba03efcc5f21c29b74775f6f257361" title="Callback that notifies the application that a calibration is needed. ">RAILCb_CalNeeded()</a> callback with the <a class="el" href="group___e_f_r32.html#ga97381526c792e093e656130c9a11f12d">RAIL_CAL_ONETIME_IRCAL</a> bit set in <a class="el" href="group___calibration.html#ga92c97ac0bc23db396309fa56c40bb8ae" title="Returns the current set of pending calibrations. ">RAIL_CalPendingGet()</a>.</li>
<li>Using a proper value for this will improve sensitivity by several dBm, so it's highly recommended.</li>
<li>It can take on the order of 700 ms to complete this calibration. You may want to save off a known good value for this calibration and load it each time you switch PHYs to save time.</li>
<li>This calibration should be initialized before channel configuration in order to provide parameters specific to the current radio config. The initialization parameters come from Simplicity Studio's application builder.</li>
<li>You cannot use the radio while this calibration is being performed or you may generate an incorrect calibration. Application code should ensure that the radio remains in the idle state during this calibration.</li>
<li>This calibration should be performed only after the radio config has been downloaded to the radio, calibration initialization has occured, and the frequency channel has been configured.</li>
</ul>
</li>
<li>VCO Temperature Calibration (VCO_TEMPCAL)<ul>
<li>If you sit in receive for a very long time and experience temperature swings it's possible for the radio to drift off frequency. When this situation is detected RAIL will request this calibration via the <a class="el" href="group___calibration.html#ga0bba03efcc5f21c29b74775f6f257361" title="Callback that notifies the application that a calibration is needed. ">RAILCb_CalNeeded()</a> callback with the <a class="el" href="group___e_f_r32.html#ga28feea6fbfddfe14e4ba5290b301081d">RAIL_CAL_TEMP_VCO</a> bit set in <a class="el" href="group___calibration.html#ga92c97ac0bc23db396309fa56c40bb8ae" title="Returns the current set of pending calibrations. ">RAIL_CalPendingGet()</a>.</li>
<li>This calibration is automatically run every time we enter receive. So if you are frequently forcing a re-enter into receive mode you may not need to enable this calibration.</li>
<li>We always recommend that you enable and handle this calibration since it doesn't add much overhead and is much safer if you ever do end up in this situation. </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Aug 16 2016 15:18:14 for RAIL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
